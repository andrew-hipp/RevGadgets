
# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getXcoord2 <- function(x, root, parent, child, len, start=0, rev=FALSE) {
    x[root] <- start
    x[-root] <- NA  ## only root is set to start, by default 0

    currentNode <- root
    direction <- 1
    if (rev == TRUE) {
        direction <- -1
    }
    while(anyNA(x)) {
        idx <- which(parent %in% currentNode)
        newNode <- child[idx]
        x[newNode] <- x[parent[idx]]+len[idx] * direction
        currentNode <- newNode
    }

    return(x)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getXcoord <- function(tr) {
    edge <- tr$edge
    parent <- edge[,1]
    child <- edge[,2]
    root <- getRoot(tr)

    len <- tr$edge.length

    N <- getNodeNum(tr)
    x <- numeric(N)
    x <- getXcoord2(x, root, parent, child, len)
    return(x)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getYcoord <- function(tr, step=1) {
    Ntip <- length(tr[["tip.label"]])
    N <- getNodeNum(tr)

    edge <- tr[["edge"]]
    parent <- edge[,1]
    child <- edge[,2]

    cl <- split(child, parent)
    child_list <- list()
    child_list[as.numeric(names(cl))] <- cl

    y <- numeric(N)
    tip.idx <- child[child <= Ntip]
    y[tip.idx] <- 1:Ntip * step
    y[-tip.idx] <- NA

    currentNode <- 1:Ntip
    while(anyNA(y)) {
        pNode <- unique(parent[child %in% currentNode])
        ## piping of magrittr is slower than nested function call.
        ## pipeR is fastest, may consider to use pipeR
        ##
        ## child %in% currentNode %>% which %>% parent[.] %>% unique
        ## idx <- sapply(pNode, function(i) all(child[parent == i] %in% currentNode))
        idx <- sapply(pNode, function(i) all(child_list[[i]] %in% currentNode))
        newNode <- pNode[idx]

        y[newNode] <- sapply(newNode, function(i) {
            mean(y[child_list[[i]]], na.rm=TRUE)
            ##child[parent == i] %>% y[.] %>% mean(na.rm=TRUE)
        })

        currentNode <- c(currentNode[!currentNode %in% unlist(child_list[newNode])], newNode)
        ## currentNode <- c(currentNode[!currentNode %in% child[parent %in% newNode]], newNode)
        ## parent %in% newNode %>% child[.] %>%
        ##     `%in%`(currentNode, .) %>% `!` %>%
        ##         currentNode[.] %>% c(., newNode)
    }

    return(y)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getParent <- function(tr, node) {
    if ( node == getRoot(tr) )
        return(0)
    edge <- tr[["edge"]]
    parent <- edge[,1]
    child <- edge[,2]
    res <- parent[child == node]
    if (length(res) == 0) {
        stop("cannot found parent node...")
    }
    if (length(res) > 1) {
        stop("multiple parent found...")
    }
    return(res)
}

################################################################################
#
# @brief Function to plot ancestral states and the associated uncertainty
#        for continuous and discrete characters.
#
#        For discrete characters 'summary_statistic="MAP"' should be used,
#        and for continuous characters 'summary_statistic="mean"'. If the
#        tree and tip labels do not fit in the screen, adjust the visible
#        area using the 'xlim_visible' argument.
#
#        If 'summary_statistic="MAP"', the maximum a posteriori ancestral
#        state will be plotted on each node. The color corresponds to the
#        character state, and the size of the circle represents the posterior
#        probability of that state. Cladogenetic models that estimate 
#        ancestral states for both the beginning and end of each branch
#        are plotted by setting "include_start_states=TRUE".
#
#        Maximum a posteriori ancestral chromosome numbers can be plotted 
#        with 'summary_statistic="MAPChromosome"'. For chromosomes the
#        color represents the posterior probability and the size of the
#        circle represents the chromosome number.
#
#        For 'summary_statistic="mean"' the color represents the size of 
#        the 95% confidence interval, and the size of the cirlce represents
#        represents the mean character state.
#
# @date Last modified: 2016-09-29
# @author Will Freyman
# @version 1.0
# @since 2016-08-31, version 1.0.0
#
# @param    tree_file               character     Path to the ancestral state tree generated by RevBayes.
# @param    summary_statistic       character   The type of summary statistic to plot.
# @param    tree_layout             character   One of 'rectangular', 'slanted', 'fan', 'circular', 'radial', or 'unrooted'.
# @param    include_start_states    logical     Plot start and end ancestral states. Used for cladogenetic models.
#
#
################################################################################
plot_ancestral_states = function(tree_file, 
                                 summary_statistic="MAP", 
                                 tree_layout="rectangular",
                                 include_start_states=FALSE, 
                                 xlim_visible=c(0, 40), 
                                 ylim_visible=NULL,
                                 tip_label_size=4, 
                                 tip_label_offset=3,
                                 tip_label_italics=FALSE,
                                 tip_node_size=2,
                                 node_label_size=4, 
                                 node_label_nudge_x=0.1, 
                                 shoulder_label_size=3, 
                                 shoulder_label_nudge_x=-0.1, 
                                 alpha=0.5, 
                                 node_size_range=c(6, 15), 
                                 color_low="#D55E00",
                                 color_mid="#F0E442",
                                 color_high="#009E73",
                                 show_state_legend=TRUE,
                                 show_posterior_legend=TRUE,
                                 state_labels=NULL,
                                 ...) { 

    if ( (summary_statistic %in% c("MAP", "mean", "MAPChromosome", "MAPRange")) == FALSE ) {
        print("Invalid summary statistic.")
        return()
    }

    # read in tree
    t = read.beast(tree_file)
    tree = attributes(t)$phylo
    n_node = getNodeNum(tree)

    #return(t)

    # remove underscores from tip labels
    attributes(t)$phylo$tip.label = gsub("_", " ", attributes(t)$phylo$tip.label)
    
    if (tip_label_italics) {
        attributes(t)$phylo$tip.label = paste("italic('", attributes(t)$phylo$tip.label, "')", sep="")
    }

    if (!is.null(state_labels)) {
        if (include_start_states) {
            x_end   = attributes(t)$stats$end_state_1
            x_start = attributes(t)$stats$start_state_1
            x_start = plyr:::mapvalues(x_start, from=levels(x_start), to=state_labels[as.numeric(levels(x_start))])
            x_end   = plyr:::mapvalues(x_end,   from=levels(x_end),   to=state_labels[as.numeric(levels(x_end))])
            attributes(t)$stats$start_state_1 = x_start
            attributes(t)$stats$end_state_1 = x_end
        }
        else {
            x_end   = attributes(t)$stats$end_state_1
            x_end   = mapvalues(x_end, from=levels(x_end), to=state_labels[as.numeric(levels(x_end))])
            attributes(t)$stats$end_state_1 = x_end
        }
    }

    # add tip labels
    p = ggtree(t, layout=tree_layout) 
    p = p + geom_tiplab(size=tip_label_size, offset=tip_label_offset, parse=tip_label_italics)
       

    if (summary_statistic == "MAPChromosome") {
        
        if (include_start_states) {
            
            if (!("start_state_1" %in% colnames(attributes(t)$stats))) {
                print("Start states not found in input tree.")
                return()
            }

            # add ancestral states as node labels
            p = p + geom_text(aes(label=end_state_1), hjust="left", nudge_x=node_label_nudge_x, size=node_label_size)

            # set the root's start state to NA
            attributes(t)$stats$start_state_1[n_node] = NA

            # add clado daughter lineage start states on "shoulders" of tree
            # get x, y coordinates of all nodes
            x = getXcoord(tree)
            y = getYcoord(tree)
            x_anc = numeric(n_node)
            node_index = numeric(n_node)
            for (i in 1:n_node) {
                if (getParent(tree, i) != 0) {
                    # if not the root, get the x coordinate for the parent node
                    x_anc[i] = x[getParent(tree, i)]
                    node_index[i] = i
                }
            }
            shoulder_data = data.frame(node=node_index, x_anc=x_anc, y=y)
            p = p %<+% shoulder_data
            
            # plot the states on the "shoulders"
            p = p + geom_text(aes(label=start_state_1, x=x_anc, y=y), hjust="right", nudge_x=shoulder_label_nudge_x, size=shoulder_label_size, na.rm=TRUE)
            
            # show ancestral states as size / posteriors as color
            p = p + geom_nodepoint(aes(colour=end_state_1_pp, size=end_state_1), alpha=alpha)
            min_low = 0.0
            max_up = 1.0
            p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=0.5)
            if (show_state_legend) {
                p = p + guides(size=guide_legend("Chromosome Number"))
            } else {
                p = p + guides(size=FALSE)
            }
            if (show_posterior_legend) {
                p = p + guides(colour=guide_legend("Posterior Probability", override.aes = list(size=8)))
            } else {
                p = p + guides(colour=FALSE)
            }
        }
    } else if (summary_statistic == "MAPRange") {
        
        if (include_start_states) {
            
            if (!("start_state_1" %in% colnames(attributes(t)$stats))) {
                print("Start states not found in input tree.")
                return()
            }

            # add ancestral states as node labels
            p = p + geom_text(aes(label=end_state_1), hjust="left", nudge_x=node_label_nudge_x, size=node_label_size)

            # set the root's start state to NA
            attributes(t)$stats$start_state_1[n_node] = NA


            # add clado daughter lineage start states on "shoulders" of tree
            # get x, y coordinates of all nodes
            x = getXcoord(tree)
            y = getYcoord(tree)
            x_anc = numeric(n_node)
            node_index = numeric(n_node)
            for (i in 1:n_node) {
                if (getParent(tree, i) != 0) {
                    # if not the root, get the x coordinate for the parent node
                    x_anc[i] = x[getParent(tree, i)]
                    node_index[i] = i
                }
            }
            shoulder_data = data.frame(node=node_index, x_anc=x_anc, y=y)
            p = p %<+% shoulder_data
           
            # plot the states on the "shoulders"
            p = p + geom_text(aes(label=start_state_1, x=x_anc, y=y), hjust="right", nudge_x=shoulder_label_nudge_x, size=shoulder_label_size, na.rm=TRUE)
            
            # show ancestral states as color / posteriors as size
            p = p + geom_nodepoint(aes(colour=factor(end_state_1), size=end_state_1_pp), alpha=alpha)

            # show tip states as color
            p = p + geom_tippoint(aes(colour=factor(end_state_1)), size=tip_node_size, alpha=alpha)

            if (show_state_legend) {
                p = p + guides(size=guide_legend("Posterior probability"))
            } else {
                p = p + guides(size=FALSE)
            }
            if (show_posterior_legend) {
                p = p + guides(colour=guide_legend("Range", override.aes = list(size=8)))
            } else {
                p = p + guides(colour=FALSE)
            }

        } else {
   
            if (!("anc_state_1" %in% colnames(attributes(t)$stats))) {
                anc_data = data.frame(node=names(attributes(t)$stats$end_state_1), 
                                      anc_state_1=as.numeric(levels(attributes(t)$stats$end_state_1))[attributes(t)$stats$end_state_1],
                                      anc_state_1_pp=as.numeric(levels(attributes(t)$stats$end_state_1_pp))[attributes(t)$stats$end_state_1_pp])
                p = p %<+% anc_data
            }

            # add end states as node labels
            p = p + geom_text(aes(label=anc_state_1), hjust="left", nudge_x=node_label_nudge_x, size=node_label_size)

            # show ancestral states as size / posteriors as color
            p = p + geom_nodepoint(aes(colour=end_state_1_pp, size=end_state_1), alpha=alpha)
            min_low = 0.0
            max_up = 1.0
            p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=0.5)
            if (show_state_legend) {
                p = p + guides(size=guide_legend("Chromosome Number"))
            } else {
                p = p + guides(size=FALSE)
            }
            if (show_posterior_legend) {
                p = p + guides(colour=guide_legend("Posterior Probability", override.aes = list(size=8)))
            } else {
                p = p + guides(colour=FALSE)
            }
        }

    } else if (summary_statistic == "MAP") {

        if (include_start_states) {
            print("Start states not yet implemented for MAP ancestral states.")
            return()
    
        }
        if (!("anc_state_1" %in% colnames(attributes(t)$stats))) {
            anc_data = data.frame(node=names(attributes(t)$stats$end_state_1), 
                                  anc_state_1=levels(attributes(t)$stats$end_state_1)[attributes(t)$stats$end_state_1],
                                  anc_state_1_pp=as.numeric(levels(attributes(t)$stats$end_state_1_pp))[attributes(t)$stats$end_state_1_pp])
            p = p %<+% anc_data
        }
        
        # add ancestral states as node labels
        p = p + geom_text(aes(label=anc_state_1), hjust="left", nudge_x=node_label_nudge_x, size=node_label_size)

        # show ancestral states as color / posteriors as size
        p = p + geom_nodepoint(aes(colour=factor(anc_state_1), size=anc_state_1_pp), alpha=alpha)
        
        # show the tip values
        p = p + geom_tippoint(aes(colour=factor(anc_state_1)), size=tip_node_size, alpha=alpha)
        
        # set up the legend
        if (show_state_legend) {
            p = p + guides(colour=guide_legend("State"))        
        } else {
            p = p + guides(colour=FALSE)
        }
        if (show_posterior_legend) {
            p = p + guides(size=guide_legend("Posterior Probability"))
        } else {
            p = p + guides(size=FALSE)
        }

    } else if (summary_statistic == "mean") {
    
        if (include_start_states) {
            print("Start states not implemented for mean ancestral states.")
            return()
        }

        # add ancestral states as node labels
        p = p + geom_text(aes(label=round(mean, 2)), hjust="left", nudge_x=node_label_nudge_x, size=node_label_size)

        # show the size of the 95% CI as color 
        lowers = as.numeric(levels(attributes(t)$stats$lower_0.95_CI))[attributes(t)$stats$lower_0.95_CI]
        uppers = as.numeric(levels(attributes(t)$stats$upper_0.95_CI))[attributes(t)$stats$upper_0.95_CI]
        diffs = uppers - lowers
        diffs_df = data.frame(node=names(attributes(t)$stats$lower_0.95_CI), diff_vals=diffs)
        p = p %<+% diffs_df 

        min_low = min(diffs, na.rm=TRUE)
        max_up = max(diffs, na.rm=TRUE)
        mid_val = min_low + (max_up - min_low) / 2.0
        p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=mid_val)
        p = p + geom_nodepoint(aes(size=mean, colour=diff_vals), alpha=alpha)

        # show the tip values
        p = p + geom_tippoint(aes(size=mean), color="grey", alpha=alpha)

        # set up the legend
        if (show_state_legend) {
            legend_text = "Mean State"
            p = p + guides(size=guide_legend(legend_text))
        } else {
            p = p + guides(size=FALSE)
        }
        if (show_posterior_legend) {
            p = p + guides(colour=guide_legend("95% CI Width", override.aes=list(size=4)))
        } else {
            p = p + guides(colour=FALSE)
        }
    
    } 
    p = p + scale_radius(range = node_size_range)
    p = p + theme(legend.position="left")

    # set visible area
    p = p + coord_cartesian(xlim = xlim_visible, ylim=ylim_visible, expand=TRUE)
    print(p)
    return(p)
}

